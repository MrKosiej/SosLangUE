Maybe we could revise how i'm currently interpreting my language. Tell me what you think and what would you change. For context, i'm making it fully in blueprints in UE5.
Base classes I'm using are ASTNode and SLangToken. ASTNode has some children like Program, Literal, Identifier, Binary and Unary. SLangToken has no children. Every leaf value is encapsulated in that SLangToken object, every operation, even if it's literal, is encapsulated in ASTNode or one of its children. Every node has ProgramContext, if the node itself is a root program, it has no program context, but we can have programs in programs, and sub programs will have program context. Every node also has an IdentityToken, which is a token which defines the Node. For example a Literal Node will return its IdentityToken, an operation will return the result of its operands based on IdentityToken, if its "-" it will perform subtraction on those operands. Every node also has Evaluation function so every node could return some value.
Every Token has Type (string), Precedence (int), Association (enum which is left or right), PossibleOperations array (unary or binary), Domain (Literal, Operator, Identifier, Keyword, Type), Value (string) and FlowControlType (for now its just for the return so i know when to break a program). Even tho it has all of those things, it mainly uses type and value for identifier and literals and domain, the rest is for operators.
At the start the ProgramNode is constructed and the script is passed. If the program is a root program, it constructs Lexer object which lexes the whole script and turns it into tokens, it categorizes tokens to domains and passes on. If the program is a sub program, we could pass lexed tokens instead and skip lexing. Then we parse the program which has two stages sort of wrapped in a loop. We have a while loop that runs if there are tokens still left. In that loop we have two stages which are RPN and AST. When they finish, we add the constructed Node to Expressions array, then we check if there are tokens still left and the loop continues.
The first stage (RPN) is looping through tokens and seeing what domain it is. If it's a literal, Identifier or Type, we add it to output array. If its operator, we check the Precedence and Association of the operator to see if we add it to operations array or pop the last operator to output. If its a keyword we can do a bunch of different things, for parenthesis it acts as a marker for order of operations, if there's a bracket it just skips checking tokens and just add them to the output, right bracket turns that off. Semicolon concludes the expression and rpn stage ends. Sorted tokens are passed to AST.
AST stage checks the domain, if its a literal it makes a LiteralNode and adds it to the stack, same for identifiers and types, operators sort of check if there are multiple possible operations but that didnt work well so i just stick with one, it check what type of operation it is and makes the operation Node (Unary of Binary) following popping Nodes from the stack, either one or two. Then it tries to evaluate the operation node, if it fails, it adds the operation node to the stack, if it succeeds, it adds a literal node with the result to the stack.
Keywords could be different things, if its a return it adds a unary operation to the stack, parenthesis act like markers and tries to figure out when to call a function, brackets just turn on and off AST checking and toggles adding following tokens to a separate array used for adding it to body of a function when declared. When program is declared its constructed with popping Nodes from the stack and added as arguments and body (from that separate array), it constructs a ProgramNode and adds it to the memory. When we try to call a function, we use identifier to access the memory and find that program.